1. Consider a function public String matchFound(String input 1, String input 2), where 
●	input1 will contain only a single word with only 1 character replaces by an underscore ‘_’
●	input2 will contain a series of words separated by colons and no space character in between
●	input2 will not contain any other special character other than underscore and alphabetic characters.
The methods should return output in a String type variable “output1” which contains all the words from input2 separated by colon which matches with input 1. All words in output1 should be in uppercase. 

CODE:-
public class WordMatcher {

    public String matchFound(String input1, String input2) {
        String[] words = input2.split(":");
        StringBuilder output1 = new StringBuilder();

        for (String word : words) {
            if (word.length() != input1.length()) continue;

            boolean match = true;
            for (int i = 0; i < word.length(); i++) {
                char c1 = input1.charAt(i);
                if (c1 != '_' && Character.toLowerCase(c1) != Character.toLowerCase(word.charAt(i))) {
                    match = false;
                    break;
                }
            }

            if (match) {
                if (output1.length() > 0) output1.append(":");
                output1.append(word.toUpperCase());
            }
        }

        return output1.toString();
    }

    // For testing
    public static void main(String[] args) {
        WordMatcher wm = new WordMatcher();
        String input1 = "h_t";
        String input2 = "hat:hot:hit:hut:heat:hoop";
        String result = wm.matchFound(input1, input2);
        System.out.println("Output1: " + result);  // Expected: HAT:HOT:HIT:HUT
    }
}











2. String t is generated by random shuffling string s and then add one more letter at a random position.
Return the letter that was added to t.
Hint:
Input: s = "abcd", t = "abcde"
Output: "e"

CODE:-
public class AddedCharFinder {

    public char findTheDifference(String s, String t) {
        char result = 0;
        for (char c : s.toCharArray()) {
            result ^= c;
        }
        for (char c : t.toCharArray()) {
            result ^= c;
        }
        return result;
    }

    public static void main(String[] args) {
        AddedCharFinder finder = new AddedCharFinder();
        String s = "abcd";
        String t = "abcde";
        System.out.println("Added character: " + finder.findTheDifference(s, t)); // Output: e
    }
}










3. The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.
You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.
For each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.
Return an array ans of length nums1.length such that ans[i] is the next greater element as described above.

CODE:-
import java.util.*;

public class NextGreaterElementFinder {

    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer, Integer> nextGreaterMap = new HashMap<>();
        Stack<Integer> stack = new Stack<>();

        // Traverse nums2 in reverse
        for (int i = nums2.length - 1; i >= 0; i--) {
            int current = nums2[i];

            // Pop all smaller or equal elements
            while (!stack.isEmpty() && stack.peek() <= current) {
                stack.pop();
            }

            // If stack is empty, no greater element to the right
            int nextGreater = stack.isEmpty() ? -1 : stack.peek();
            nextGreaterMap.put(current, nextGreater);

            // Push current element to stack
            stack.push(current);
        }

        // Build result using map for each element in nums1
        int[] result = new int[nums1.length];
        for (int i = 0; i < nums1.length; i++) {
            result[i] = nextGreaterMap.get(nums1[i]);
        }

        return result;
    }

    // Test case
    public static void main(String[] args) {
        NextGreaterElementFinder finder = new NextGreaterElementFinder();
        int[] nums1 = {4, 1, 2};
        int[] nums2 = {1, 3, 4, 2};
        int[] result = finder.nextGreaterElement(nums1, nums2);
        System.out.println("Next greater elements: " + Arrays.toString(result));
        // Output: [-1, 3, -1]
    }
}













4. A string containing only parentheses is balanced if the following is true: 1. if it is an empty string 2. if A and B are correct, AB is correct, 3. if A is correct, (A) and {A} and [A] are also correct.
Examples of some correctly balanced strings are: "{}()", "[{()}]", "({()})"
Examples of some unbalanced strings are: "{}(", "({)}", "[[", "}{" etc.
Given a string, determine if it is balanced or not.
Input Format
There will be multiple lines in the input file, each having a single non-empty string. You should read input till end-of-file.
Output Format
For each case, print 'true' if the string is balanced, 'false' otherwise

CODE:-
import java.util.*;
import java.io.*;

public class BalancedBrackets {

    public static boolean isBalanced(String s) {
        Stack<Character> stack = new Stack<>();

        for (char ch : s.toCharArray()) {
            if (ch == '(' || ch == '{' || ch == '[') {
                stack.push(ch);
            } else {
                if (stack.isEmpty()) return false;
                char top = stack.pop();
                if ((ch == ')' && top != '(') ||
                    (ch == '}' && top != '{') ||
                    (ch == ']' && top != '[')) {
                    return false;
                }
            }
        }

        return stack.isEmpty();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        while (scanner.hasNextLine()) {
            String line = scanner.nextLine().trim();
            if (!line.isEmpty()) {
                System.out.println(isBalanced(line));
            }
        }

        scanner.close();
    }
}











5. Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:
•	'?' Matches any single character.
•	'*' Matches any sequence of characters (including the empty sequence).
The matching should cover the entire input string (not partial).
 
CODE:-
public class WildcardMatcher {

    public boolean isMatch(String s, String p) {
        int m = s.length(), n = p.length();
        boolean[][] dp = new boolean[m + 1][n + 1];

        // Empty string and empty pattern are a match
        dp[0][0] = true;

        // Handle patterns with * at the beginning
        for (int j = 1; j <= n; j++) {
            if (p.charAt(j - 1) == '*') {
                dp[0][j] = dp[0][j - 1];
            }
        }

        // Fill DP table
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                char sc = s.charAt(i - 1);
                char pc = p.charAt(j - 1);

                if (pc == '?' || pc == sc) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (pc == '*') {
                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];
                }
            }
        }

        return dp[m][n];
    }

    // Test the function
    public static void main(String[] args) {
        WildcardMatcher wm = new WildcardMatcher();

        // Test cases
        System.out.println(wm.isMatch("aa", "a"));       // false
        System.out.println(wm.isMatch("aa", "*"));       // true
        System.out.println(wm.isMatch("cb", "?a"));      // false
        System.out.println(wm.isMatch("adceb", "*a*b")); // true
        System.out.println(wm.isMatch("acdcb", "a*c?b")); // false
    }
}
